/*
 * Copyright (c) 2015 Nikolay Zapolnov (zapolnov@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once
#include "core/interfaces/IUnknown.h"
#include "core/interfaces/system/ISystem.h"
#include "core/interfaces/system/ISystemEventLoop.h"
#include "core/utility/TypeID.h"
#include "core/utility/Ptr.h"
#include "core/utility/debug.h"
#include <vector>
#include <unordered_map>

namespace Engine
{
    /**
     * A core of the engine.
     * This class provides global API to glue different components of the engine.
     */
    class Core
    {
    public:
        /**
         * Retrieves an instance of the singleton.
         * @return Instance of the Engine Core.
         */
        static Core& instance()
        {
            Z_ASSERT(m_Instance != nullptr);
            return *m_Instance;
        }

        /**
         * Retrieves an instance of the operating system API wrapper.
         * @return Instance of the operating system API wrapper.
         */
        static ISystem& system()
        {
            Z_ASSERT(m_System != nullptr);
            return *m_System;
        }

        /**
         * Adds an instance of the singleton to the core.
         * @param singleton Singleton object to add.
         */
        void addSingleton(IUnknown* singleton);

        /**
         * Queries for singleton of the specified type from the core.
         * @param typeID Type of the singleton object.
         * @return Pointer to the singleton object or `nullptr` if there is no such singleton in the core.
         */
        void* querySingleton(TypeID typeID);

        /**
         * Queries for singleton of the specified type from the core.
         * @tparam TYPE Type of the singleton object.
         * @return Pointer to the singleton object or `nullptr` if there is no such singleton in the core.
         */
        template <class TYPE> TYPE* querySingleton()
        {
            return reinterpret_cast<TYPE*>(querySingleton(typeOf<TYPE>()));
        }

        /**
         * Runs the engine.
         * @param eventLoop Event loop of the UI thread.
         * @return Exit code.
         */
        static int run(ISystemEventLoop* eventLoop);

    private:
        /** An initializer class that is generated by the build system. */
        class Initializer
        {
            static void init(Core& core);
            friend class Core;
        };

        static Core* m_Instance;
        static ISystem* m_System;

        std::vector<Ptr<IUnknown>> m_SingletonList;
        std::unordered_map<TypeID, void*> m_SingletonMap;

        Core();
        ~Core();
        Z_DISABLE_COPY(Core);
    };
}
